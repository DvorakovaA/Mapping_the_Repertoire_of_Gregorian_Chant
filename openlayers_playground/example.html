<!DOCTYPE html>
<html>
  <head>
    <title>Practice for thesis</title>
    <link rel="stylesheet" href="https://openlayers.org/en/v4.6.5/css/ol.css" type="text/css">
    <!-- The line below is only needed for old environments like Internet Explorer and Android 4.x -->
    <script src="https://cdn.polyfill.io/v2/polyfill.min.js?features=requestAnimationFrame,Element.prototype.classList,URL"></script>
    <script src="https://openlayers.org/en/v4.6.5/build/ol.js"></script>
    <style>
      .ol-touch .rotate-north {
        top: 80px;
      }
    </style>
  </head>
  <body>
    <div id="map" class="map"> <div id="popup"> </div> </div>
    <script>
      /**
       * Define a namespace for the application.
       */
      window.app = {};
      var app = window.app;
      
      // Geometries
      var point1 = new ol.geom.Point(
          ol.proj.transform([2.1833, 41.3833], 'EPSG:4326', 'EPSG:3857')
      );
      var point2 = new ol.geom.Point(
          ol.proj.transform([2.1833, 41.3833], 'EPSG:4326', 'EPSG:3857')
      );
      var point = new ol.geom.Point(
          ol.proj.transform([4.1833, 41.3833], 'EPSG:4326', 'EPSG:3857'),
      )

      // Features
      var point1Feature = new ol.Feature(point1);
      var point2Feature = new ol.Feature(point2);
      var pointFeature = new ol.Feature(point);

      // Source and vector layer 1
      var vectorSource1 = new ol.source.Vector({
          projection: 'EPSG:4326'
      });
      vectorSource1.addFeatures([point2Feature, point1Feature, pointFeature]);

      var vectorLayer1 = new ol.layer.Vector({
          source: vectorSource1
      });

      // Source and vector layer 2
      var vectorSource2 = new ol.source.Vector({
          projection: 'EPSG:4326'
      });
      vectorSource2.addFeatures([point2Feature, point1Feature, pointFeature]);

      var vectorLayer2 = new ol.layer.Vector({
          source: vectorSource2
      });

      // Line
      var points = [ [2.1833, 41.3833], [4.1833, 41.3833] ];

      for (var i = 0; i < points.length; i++) {
          points[i] = ol.proj.transform(points[i], 'EPSG:4326', 'EPSG:3857');
      }

      var featureLine = new ol.Feature({
          geometry: new ol.geom.LineString(points)
      });

      var vectorLine = new ol.source.Vector({});
      vectorLine.addFeature(featureLine);

      var vectorLineLayer = new ol.layer.Vector({
          source: vectorLine,
          style: new ol.style.Style({
              fill: new ol.style.Fill({ color: '#00FF00', weight: 4 }),
              stroke: new ol.style.Stroke({ color: '#00FF00', width: 2 })
          })
      });



      //Clustering part
      const circleDistanceMultiplier = 1;
      const circleFootSeparation = 28;
      const circleStartAngle = Math.PI / 2;

      const convexHullFill = new ol.style.Fill({
        color: 'rgba(255, 153, 0, 0.4)',
      });

      const convexHullStroke = new ol.style.Stroke({
        color: 'rgba(204, 85, 0, 1)',
        width: 1.5,
      });

      const outerCircleFill = new ol.style.Fill({
        color: 'rgba(255, 153, 102, 0.3)',
      });
      const innerCircleFill = new ol.style.Fill({
        color: 'rgba(255, 165, 0, 0.7)',
      });
      const textFill = new ol.style.Fill({
        color: '#fff',
      });
      const textStroke = new ol.style.Stroke({
        color: 'rgba(0, 0, 0, 0.6)',
        width: 3,
      });
      const innerCircle = new ol.style.Circle({
        radius: 14,
        fill: innerCircleFill,
      });
      const outerCircle = new ol.style.Circle({
        radius: 20,
        fill: outerCircleFill,
      });
     
      /**
       * Single feature style, users for clusters with 1 feature and cluster circles.
       * @param {Feature} clusterMember A feature from a cluster.
       * @return {Style} An icon style for the cluster member's location.
       
      function clusterMemberStyle(clusterMember) {
        return new Style({
          geometry: clusterMember.getGeometry()
        });
      }

      let clickFeature, clickResolution;
      */
      /**
       * Style for clusters with features that are too close to each other, activated on click.
       * @param {Feature} cluster A cluster with overlapping members.
       * @param {number} resolution The current view resolution.
       * @return {Style|null} A style to render an expanded view of the cluster members.
       
      function clusterCircleStyle(cluster, resolution) {
        if (cluster !== clickFeature || resolution !== clickResolution) {
          return null;
        }
        const clusterMembers = cluster.get('features');
        const centerCoordinates = cluster.getGeometry().getCoordinates();
        return generatePointsCircle(
          clusterMembers.length,
          cluster.getGeometry().getCoordinates(),
          resolution,
        ).reduce((styles, coordinates, i) => {
          const point = new Point(coordinates);
          const line = new LineString([centerCoordinates, coordinates]);
          styles.unshift(
            new Style({
              geometry: line,
              stroke: convexHullStroke,
            }),
          );
          styles.push(
            clusterMemberStyle(
              new Feature({
                ...clusterMembers[i].getProperties(),
                geometry: point,
              }),
            ),
          );
          return styles;
        }, []);
      }
*/
      /**
       * From
       * https://github.com/Leaflet/Leaflet.markercluster/blob/31360f2/src/MarkerCluster.Spiderfier.js#L55-L72
       * Arranges points in a circle around the cluster center, with a line pointing from the center to
       * each point.
       * @param {number} count Number of cluster members.
       * @param {Array<number>} clusterCenter Center coordinate of the cluster.
       * @param {number} resolution Current view resolution.
       * @return {Array<Array<number>>} An array of coordinates representing the cluster members.
       
      function generatePointsCircle(count, clusterCenter, resolution) {
        const circumference =
          circleDistanceMultiplier * circleFootSeparation * (2 + count);
        let legLength = circumference / (Math.PI * 2); //radius from circumference
        const angleStep = (Math.PI * 2) / count;
        const res = [];
        let angle;

        legLength = Math.max(legLength, 35) * resolution; // Minimum distance to get outside the cluster icon.

        for (let i = 0; i < count; ++i) {
          // Clockwise, like spiral.
          angle = circleStartAngle + i * angleStep;
          res.push([
            clusterCenter[0] + legLength * Math.cos(angle),
            clusterCenter[1] + legLength * Math.sin(angle),
          ]);
        }

        return res;
      }

      let hoverFeature;
*/
      /**
       * Style for convex hulls of clusters, activated on hover.
       * @param {Feature} cluster The cluster feature.
       * @return {Style|null} Polygon style for the convex hull of the cluster.
       
      function clusterHullStyle(cluster) {
        if (cluster !== hoverFeature) {
          return null;
        }
        const originalFeatures = cluster.get('features');
        const points = originalFeatures.map((feature) =>
          feature.getGeometry().getCoordinates(),
        );
        return new Style({
          geometry: new Polygon([monotoneChainConvexHull(points)]),
          fill: convexHullFill,
          stroke: convexHullStroke,
        });
      }

      function clusterStyle(feature) {
        const size = feature.get('features').length;
        if (size > 1) {
          return [
            new Style({
              image: outerCircle,
            }),
            new Style({
              image: innerCircle,
              text: new Text({
                text: size.toString(),
                fill: textFill,
                stroke: textStroke,
              }),
            }),
          ];
        }
        const originalFeature = feature.get('features')[0];
        return clusterMemberStyle(originalFeature);
      }
*/
      // Connect to our data
      // Layer displaying the clusters and individual features.
/*
      const clusters = new VectorLayer({
        source: vectorSource1,
        style: clusterStyle,
      });

      // Layer displaying the expanded view of overlapping cluster members.
      const clusterCircles = new VectorLayer({
        source: clusterSource,
        style: clusterCircleStyle,
      });
*/

      // MAP
      const center = ol.proj.transform([11.166667, 47.466667], 'EPSG:4326', 'EPSG:3857');
      const view = new ol.View({
          center: center,
          zoom: 5,
          //projection: 'EPSG:4326'
        });
      var map = new ol.Map({
        layers: [
              // Add a new Tile layer getting tiles from OpenStreetMap source
              new ol.layer.Tile({
                  source: new ol.source.OSM()
              }),
              vectorLayer1,
              vectorLayer2,
              vectorLineLayer
              //clusterCircles,
              //clusters
          ],

        target: document.getElementById('map'),
        view: view
      });

      const element = document.getElementById('popup'); //v jejich htmlje na to  s id popup

      const popup1 = new Overlay({
        element: element,
        positioning: 'bottom-center',
        stopEvent: false,
      });
      map.addOverlay(popup1);

      let popover;
      function disposePopover() {
        if (popover) {
          popover.dispose();
          popover = undefined;
        }
      }
      // display popup on click
      map.on('click', function (evt) {
        const feature = map.forEachFeatureAtPixel(evt.pixel, function (feature) {
          return feature;
        });
        disposePopover();
        if (!feature) {
          return;
        }
        popup.setPosition(evt.coordinate);
        popover = new bootstrap.Popover(element, {
          placement: 'top',
          html: true,
          content: feature.get('name'),
        });
        popover.show();
      });

      // change mouse cursor when over marker
      map.on('pointermove', function (e) {
        const pixel = map.getEventPixel(e.originalEvent);
        const hit = map.hasFeatureAtPixel(pixel);
        map.getTarget().style.cursor = hit ? 'pointer' : '';
      });
      // Close the popup when the map is moved
      map.on('movestart', disposePopover);
      

    </script>
  </body>
</html>